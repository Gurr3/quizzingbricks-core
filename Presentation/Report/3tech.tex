The project is built with several technologies with key components built with the programming languages Python and Scala with support of different libraries and toolkits.

\subsection{Tools}
\subsubsection{Git}
The version control system used in the project was Git\cite{ref_git} and hosted on \url{http://github.com} because we all had some previous experience with this setup. On github we used a shared organization account (\url{http://github.com/quizzingbricks}) with our repositories and let the contributors to fork the main repository and send pull requests to merge back into the main repository.
\subsubsection{Vagrant}
Vagrant\cite{ref_vagrant} is a tool that lets developers create and use reproducible and portable environments. We chose to use Vagrant because we wanted all developers to share a common view with all tools pre-installed and let each developer focus on coding rather than operations and configure its own machine. The same provisioning script to install all packages in the virtual machine was also used on the server in our production environment with some additional configuration. 
\subsubsection{OpenStack}
OpenStack\cite{ref_openstack} is an open source platform for private and public clouds similar to Amazon's Web Services (AWS) and Google's Cloud Platform. Since we used Vagrant for our local development environment the task to deploy and manage the staging and production environment for the virtual machines was easy because the same provision of installable packages was re-used in the OpenStack as well which enabled us to have the same environment in development and production.

\subsection{Backend}
\subsubsection{Python and Gevent}
The Python language\cite{ref_python} is a general-purpose and high-level dynamic programming language and is used for most of our internal services (read more below about services in section \ref{zmq_protobuf}) and the web client and also our HTTP-based RESTful API that power our mobile clients. Gevent\cite{ref_gevent} is a coroutine-based networking library that enable event-driven concurrency in Python instead of thread-based concurrency. The use of gevent and non-blocking I/O enable the services and HTTP-based web and RESTful API to allow higher concurrency and more simultaneous connections which is used for websockets that the API and web client expose.
\subsubsection{Scala and akka}
Scala\cite{ref_scala} is a programming language which is syntactically close to its ancestor Java and can also be compiled to Java bytecode and use Java libraries directly in its code. The powerful object-oriented concepts in Java are included in Scala, but Scala also features extensive capabilities for functional programming, which include many features found in many purely functional languages such as pattern matching, immutability and lazy evaluation. Scala also extends the type system of Java into a unified type system together with higher-order types including co- and contravariant structures. It supports immutability and provides language and library means for writing code completely free of side-effects if desired.\\
Included in the native library of Scala is akka\cite{ref_akka}, which is a toolkit written for the Java platform that provides a framework for writing concurrency-based code through an implementation of the actor model of synchronous computing. Actors are objects that are constructed in a hierarchical fashion to allow for supervision and failover and communicate through a message mechanism. The akka toolkit is intended to provide for scalability by allowing each actor to seamlessly serve as an abstraction for anything from a thread to a server cluster.
\subsubsection{$\varnothing$MQ and Protocol Buffers\label{zmq_protobuf}}
$\varnothing$MQ\cite{ref_zmq} is a socket library that enhances the socket programming and includes multiple message patterns were we use request/reply and publish/subscribe. Request/reply is used for client/server communication and publish/subscribe is used as a single publisher publish messages to potentially multiple listeners. Google's Protocol Buffers\cite{ref_protobuf} is a serialization format that enables multiple languages to share the same transport format and protocol. Another popular method is to use a RESTful API over HTTP with JSON as transport format. As we evaluated the combinations we ended up with the ZeroMQ and Protocol Buffer approach since the HTTP adds an overhead on the TCP and also because we designed the protocol to only use request/reply without any special features that HTTP enables but also since we needed publish/subscribe and that is not supported by HTTP.
\subsubsection{Database Technologies}
For persistence of data, the relational database system PostgreSQL\cite{ref_postgres} is used, which is accessed through the SQLAlchemy\cite{ref_sqlalchemy} toolkit for the Python language, and the Slick\cite{ref_slick} toolkit for Scala. The tool Alembic\cite{ref_alembic} has been used to migrate between database versions during development.

\subsection{iOS 7}
The iOS client needs to be written in Objective C and the only choice you have is trying to use a third party development tool that translates code into objective c. The problem with these tools is that they actually restrict you even further than Apple does with their tools and you end up with an application that doesn't feel good enough, so we decided to develop directly in Xcode using objective c. Apple provides a foundation framework that actually includes all the things we needed for our application from Strings to url requests and json parsing so no use for external libraries has arisen. 

\subsection{Android}
Android uses java and xml to make applications, the graphical design is most often done in xml and uses java for functionality. But the graphic can be made in java as well, which allows for dynamic layouts compared to xml's static layouts. 
This project focused on developing for Android phones running version 4.0 (Ice Cream Sandwich) and above. The main reason for this decision is that the percentage of devices running older version is around 20\%\cite{ref_android_versions} and by excluding the backwards compatibility more focus could be put on making a better ui using the newer API:s. This also gives our application more of a modern look which is harder to mimic with the older API versions.
As for the development environment there are two official choices offered by Google, Android Studio and Eclipse. For this project we choose to work with Eclipse since Android Studio is still in beta. But as a IDE Eclipse has some flaws and one of the major ones is the amount of files that are included in each project which makes backing up files an unnecessary hassle.

\subsection{Web}
\subsubsection{HTML5}
HTML Is a markup language used for structuring and presenting information on the Internet. HTML5\cite{ref_html5_1}\cite{ref_html5_2} is the latest iteration of the HTML standard. And is more closely working with JavaScript (JS) and Cascading Style Sheets (CSS). This technology has mainly been used for the above reason that is structuring and presenting the information on our web platform. Where Bootstrap has been the backbone in the design with the navigation bar layout and grid layouts for the body of the webpage and basic clean CSS. In addition to this JS has been used for additional functionality on the game board page. 
\subsubsection{Websockets}
Websockets\cite{ref_websocket} is a protocol that got full-duplex communication channel of a single TCP connection. In the web applications it have been used to receive message containing information about changes of the game and player states in the backend. When these messages was received they called JS functions that updated the game board as soon as a full game round have been completed, they are also used to change the player status for a specific player whose state was changed.
\subsubsection{Flask}
Flask\cite{ref_flask} is a micro framework written in Python and is based on Werkzeug WSGI toolkit and the template engine Jinja2\cite{ref_jinja2}. Flask is used to implement the HTTP end-points for both the web application and the RESTful API that is used by the mobile clients.

